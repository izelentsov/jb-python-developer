type: edu
custom_name: stage2
files:
- name: tests.py
  visible: false
  text: |
    from hstest.stage_test import *
    from hstest.test_case import TestCase
    from enum import Enum
    from typing import List, Optional
    from copy import deepcopy

    CheckResult.correct = lambda: CheckResult(True, '')
    CheckResult.wrong = lambda feedback: CheckResult(False, feedback)


    class FieldState(Enum):
        X = 'X'
        O = 'O'
        FREE = ' '


    def get_state(symbol):
        if symbol == 'X':
            return FieldState.X
        elif symbol == 'O':
            return FieldState.O
        elif symbol == ' ' or symbol == '_':
            return FieldState.FREE
        else:
            return None


    class TicTacToeField:

        def __init__(self, *, field: str = '', constructed=None):

            if constructed is not None:
                self.field = deepcopy(constructed)

            else:
                self.field: List[List[Optional[FieldState]]] = [
                    [None for _ in range(3)] for _ in range(3)
                ]

                for row in range(3):
                    for col in range(3):
                        index = (2 - row) * 3 + col
                        self.field[row][col] = get_state(field[index])

        def equal_to(self, other) -> bool:
            for i in range(3):
                for j in range(3):
                    if self.field[i][j] != other.field[i][j]:
                        return False
            return True

        def has_next_as(self, other) -> bool:
            improved: bool = False
            for i in range(3):
                for j in range(3):
                    if self.field[i][j] != other.field[i][j]:
                        if self.field[i][j] == FieldState.FREE and not improved:
                            improved = True
                        else:
                            return False
            return improved

        def differ_by_one(self, other) -> bool:
            have_single_difference = False
            for i in range(3):
                for j in range(3):
                    if self.field[i][j] != other.field[i][j]:
                        if have_single_difference:
                            return False
                        have_single_difference = True
            return have_single_difference

        def is_close_to(self, other) -> bool:
            return (
                self.equal_to(other)
                or self.has_next_as(other)
                or other.has_next_as(self)
            )

        @staticmethod
        def parse(field_str: str):

            lines = field_str.splitlines()
            lines = [i.strip() for i in lines]
            lines = [i for i in lines if
                     i.startswith('|') and i.endswith('|')]

            for line in lines:
                for c in line:
                    if c not in 'XO|_ ':
                        return None

            field: List[List[Optional[FieldState]]] = [
                [None for _ in range(3)] for _ in range(3)
            ]

            y: int = 2

            for line in lines:
                cols = line[2], line[4], line[6]
                x: int = 0
                for c in cols:
                    state = get_state(c)
                    if state is None:
                        return None
                    field[y][x] = state
                    x += 1
                y -= 1

            return TicTacToeField(constructed=field)

        @staticmethod
        def parse_all(output: str):
            fields = []

            lines = output.splitlines()
            lines = [i.strip() for i in lines]
            lines = [i for i in lines if len(i) > 0]

            candidate_field = ''
            inside_field = False
            for line in lines:
                if '----' in line and not inside_field:
                    inside_field = True
                    candidate_field = ''
                elif '----' in line and inside_field:
                    field = TicTacToeField.parse(candidate_field)
                    if field is not None:
                        fields += [field]
                    inside_field = False

                if inside_field and line.startswith('|'):
                    candidate_field += line + '\n'

            return fields


    inputs = [
        "1 1", "1 2", "1 3",
        "2 1", "2 2", "2 3",
        "3 1", "3 2", "3 3"
    ]


    def iterate_cells(initial: str) -> str:
        index: int = -1
        for i in range(len(inputs)):
            if initial == inputs[i]:
                index = i
                break

        if index == -1:
            return ''

        full_input: str = ''
        for i in range(index, index + 9):
            full_input += inputs[i % len(inputs)] + '\n'

        return full_input


    class TicTacToeTest(StageTest):
        def generate(self) -> List[TestCase]:
            tests: List[TestCase] = []

            i: int = 0
            for input in inputs:
                full_move_input = iterate_cells(input)

                str_nums = input.split()
                x = int(str_nums[0])
                y = int(str_nums[1])

                if i % 2 == 1:
                    full_move_input = f'4 {i}\n' + full_move_input

                full_game_input = ''
                for _ in range(9):
                    full_game_input += full_move_input

                tests += [
                    TestCase(
                        stdin=full_game_input,
                        attach=(x, y)
                    )
                ]

                i += 1

            return tests

        def check(self, reply: str, attach: str) -> CheckResult:

            clue_x, clue_y = attach

            fields = TicTacToeField.parse_all(reply)

            if len(fields) == 0:
                return CheckResult.wrong(
                    "No fields found"
                )

            for i in range(1, len(fields)):
                curr: TicTacToeField = fields[i - 1]
                next: TicTacToeField = fields[i]

                stayed = curr.equal_to(next)
                improved = curr.has_next_as(next)

                if not (stayed or improved):
                    return CheckResult.wrong(
                        "For two fields following each " +
                        "other one is not a continuation " +
                        "of the other (they differ more than in two places)."
                    )

            if "Making move level \"easy\"" not in reply:
                return CheckResult.wrong(
                    "No \"Making move level \"easy\"\" line in output"
                )

            return CheckResult.correct()


    if __name__ == '__main__':
        TicTacToeTest('tictactoe.tictactoe').run_tests()
  learner_created: false
- name: tictactoe/tictactoe.py
  visible: true
  text: |
    # write your code here

    SIDE_X = 'X'
    SIDE_O = 'O'
    BLANK = '_'

    ST_NONE = 0
    ST_DRAW = 1
    ST_X_WINS = 2
    ST_O_WINS = 3


    def main():
        field = get_field()
        print_field(field)
        play(field)


    def get_field():
        f = input('Enter cells: ')
        r1 = list(f[:3])
        r2 = list(f[3: 6])
        r3 = list(f[6:9])
        return [r1, r2, r3]


    def print_field(f):
        print_line()
        for r in f:
            print_row(r)
        print_line()


    def print_line():
        print('-' * 9)


    def print_row(r):
        print('|', ' '.join(r), '|')


    def play(f):
        side = whose_turn(f)
        move = ask_move(f)
        if move:
            make_move(f, side, move)
            print_field(f)
            state = game_state(f)
            print_state(state)


    def whose_turn(f):
        xs = count_side(f, SIDE_X)
        os = count_side(f, SIDE_O)
        return SIDE_X if xs == os else SIDE_O


    def count_side(f, side):
        return len([cell for row in f for cell in row if cell == side])


    def ask_move(f):
        move = None
        while not move:
            inp = input('Enter the coordinates: ')
            ux, uy = parse_input(inp)
            if ux is not None:
                move = to_field_coords(ux, uy)
                if is_occupied(f, move):
                    print('This cell is occupied! Choose another one!')
                    move = None
                else:
                    break
        return move


    def parse_input(inp):
        # if any(not c.isdigit() for c in inp):
        #     print('You should enter numbers!')
        #     return None, None
        try:
            coords = [int(c) for c in inp.split(' ')]
        except ValueError:
            print('You should enter numbers!')
            return None, None

        if any(x < 1 or x > 3 for x in coords):
            print('Coordinates should be from 1 to 3!')
            return None, None

        return coords[0], coords[1]


    def to_field_coords(ux, uy):
        return ux - 1, 3 - uy


    def is_occupied(f, xy):
        return f[xy[1]][xy[0]] != BLANK


    def make_move(f, side, move):
        f[move[1]][move[0]] = side


    def game_state(f):
        winner = get_winner(f)
        if winner == SIDE_O:
            return ST_O_WINS
        if winner == SIDE_X:
            return ST_X_WINS
        if has_blanks(f):
            return ST_NONE
        return ST_DRAW


    def get_winner(f):
        for row in f:
            winner = who_strikes(row)
            if winner:
                return winner

        for x in range(3):
            col = [row[x] for row in f]
            winner = who_strikes(col)
            if winner:
                return winner

        diag = [f[x][x] for x in range(3)]
        winner = who_strikes(diag)
        if winner:
            return winner

        diag = [f[x][2 - x] for x in range(3)]
        winner = who_strikes(diag)
        if winner:
            return winner

        return None


    def has_blanks(f):
        return any(c == BLANK for row in f for c in row)


    def who_strikes(line):
        if all(c == SIDE_X for c in line):
            return SIDE_X
        if all(c == SIDE_O for c in line):
            return SIDE_O
        return None


    def print_state(state):
        if state == ST_NONE:
            print('Game not finished')
        if state == ST_DRAW:
            print("Draw")
        if state == ST_X_WINS:
            print("X wins")
        if state == ST_O_WINS:
            print("O wins")


    main()
  learner_created: false
feedback_link: https://hyperskill.org/projects/82/stages/453/implement
status: Solved
record: -1
